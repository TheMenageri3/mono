model AdminComment {
  id         String     @id @default(uuid())
  visibility Visibility
  category   Category
  priority   Priority   @default(NORMAL)
  resolved   Boolean    @default(false)

  commentId String?
  comment   Comment? @relation(fields: [commentId], references: [id])

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  createdById String
  createdBy   User   @relation("AdminCommentCreatedBy", fields: [createdById], references: [id])

  updatedById String
  updatedBy   User   @relation("AdminCommentUpdatedBy", fields: [updatedById], references: [id])
}

enum Category {
  FEEDBACK
  EVALUATION
  INTERNAL_NOTE
  DECISION_RATIONALE
  FOLLOWUP_REQUIRED
}

enum Priority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum Visibility {
  ADMIN_ONLY
  INSTRUCTORS_ONLY
  STAFF_AND_INSTRUCTORS
  STAFF_INSTRUCTORS_AND_STUDENT // New option for staff + instructors + the specific student
  PUBLIC
}

model Answer {
  id         String    @id @default(uuid())
  questionId String
  question   Question  @relation(fields: [questionId], references: [id])
  value      Json?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  deletedAt  DateTime?

  createdById String
  createdBy   User   @relation("AnswerCreatedBy", fields: [createdById], references: [id])

  updatedById String
  updatedBy   User   @relation("AnswerUpdatedBy", fields: [updatedById], references: [id])

  assignmentSubmissionAnswers AssignmentSubmissionAnswer[]
  classApplicationAnswers     ClassApplicationAnswer[]
  tags                        Tag[]                        @relation("AnswerTags")
  Assignment                  Assignment?                  @relation(fields: [assignmentId], references: [id])
  assignmentId                String?
}

model Assignment {
  id                     String                 @id @default(uuid())
  title                  String
  description            String
  type                   AssignmentType
  status                 AssignmentStatus
  submissionType         SubmissionType
  submissionInstructions String
  submissions            AssignmentSubmission[]
  pointsPossible         Float?
  gradingRubric          Json?
  releaseDate            DateTime?
  dueDate                DateTime?
  allowLateSubmissions   Boolean?               @default(false)
  latePenalty            Json?
  createdAt              DateTime               @default(now())
  updatedAt              DateTime               @updatedAt
  deletedAt              DateTime?

  createdById String
  createdBy   User   @relation("AssignmentCreatedBy", fields: [createdById], references: [id])

  updatedById String
  updatedBy   User   @relation("AssignmentUpdatedBy", fields: [updatedById], references: [id])

  classId String
  class   Class  @relation(fields: [classId], references: [id])

  tags      Tag[]                @relation("AssignmentTags")
  questions AssignmentQuestion[]
  answers   Answer[]
  Comment   Comment[]
}

enum AssignmentType {
  INDIVIDUAL
  GROUP
  EXAM
  PROJECT
  PREREQUISITE
}

enum AssignmentStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum SubmissionType {
  TEXT
  FILE
  LINK
  CODE
  MIXED
}

model AssignmentQuestion {
  id           String     @id @default(uuid())
  assignment   Assignment @relation(fields: [assignmentId], references: [id])
  assignmentId String
  question     Question   @relation(fields: [questionId], references: [id])
  questionId   String
  order        Int
  required     Boolean
  points       Float
  section      String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  createdById String
  updatedById String

  createdBy                  User                         @relation("AssignmentQuestionCreatedBy", fields: [createdById], references: [id])
  updatedBy                  User                         @relation("AssignmentQuestionUpdatedBy", fields: [updatedById], references: [id])
  AssignmentSubmissionAnswer AssignmentSubmissionAnswer[]
}

model AssignmentSubmission {
  id             String           @id @default(uuid())
  assignment     Assignment       @relation(fields: [assignmentId], references: [id])
  assignmentId   String
  status         SubmissionStatus
  submissionText String?
  submissionUrl  String?
  files          Media[]          @relation("AssignmentSubmissionFiles")
  submittedAt    DateTime?        @default(now())
  gradedAt       DateTime?

  score    Float?
  feedback String?

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // audit fields
  createdById String
  updatedById String

  // in middleware filter out if the user grading it has Instructor role
  gradedBy   User?   @relation("GradedBy", fields: [gradedById], references: [id])
  gradedById String?

  createdBy                  User                         @relation("AssignmentSubmissionCreatedBy", fields: [createdById], references: [id])
  updatedBy                  User                         @relation("AssignmentSubmissionUpdatedBy", fields: [updatedById], references: [id])
  Profile                    Profile?                     @relation(fields: [profileId], references: [id])
  profileId                  String?
  AssignmentSubmissionAnswer AssignmentSubmissionAnswer[]
}

enum SubmissionStatus {
  DRAFT
  SUBMITTED
  LATE
  GRADED
}

model AssignmentSubmissionAnswer {
  id                     String    @id @default(uuid())
  assignmentSubmissionId String
  questionId             String
  assignmentQuestionId   String // Added to link to AssignmentQuestion
  answerId               String? // Optional link to Answer model
  value                  Json
  feedback               String?
  pointsAwarded          Float?
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt
  deletedAt              DateTime?
  createdById            String
  updatedById            String

  // Relations
  createdBy            User                 @relation("AssignmentSubmissionAnswerCreatedBy", fields: [createdById], references: [id])
  updatedBy            User                 @relation("AssignmentSubmissionAnswerUpdatedBy", fields: [updatedById], references: [id])
  assignmentSubmission AssignmentSubmission @relation(fields: [assignmentSubmissionId], references: [id])
  question             Question             @relation(fields: [questionId], references: [id])
  assignmentQuestion   AssignmentQuestion   @relation(fields: [assignmentQuestionId], references: [id])
  answer               Answer?              @relation(fields: [answerId], references: [id])

  @@unique([assignmentSubmissionId, questionId])
}

enum QuarterType {
  FALL
  WINTER
  SUMMER
  SPRING
}

enum StatusType {
  UPCOMING
  ACTIVE
  COMPLETED
  CANCELLED
}

model Class {
  id                 String      @id @default(uuid())
  title              String
  description        String
  shortDescription   String
  year               Int
  quarter            QuarterType
  status             StatusType
  startDate          DateTime
  endDate            DateTime
  enrollmentCapacity Int
  syllabusUrl        String
  meetingSchedule    Json
  location           String
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt
  deletedAt          DateTime?

  createdById String
  createdBy   User   @relation("ClassCreatedBy", fields: [createdById], references: [id])

  updatedById String
  updatedBy   User   @relation("ClassUpdatedBy", fields: [updatedById], references: [id])

  assignments        Assignment[]
  teachers           User[]             @relation("ClassTeachers")
  teachingAssistants User[]             @relation("ClassTeachingAssistants")
  enrollments        Enrollment[]
  applications       ClassApplication[]
  projects           Project[]          @relation("ClassProjects")
}

model ClassApplication {
  id          String            @id @default(uuid())
  title       String
  description String
  classId     String
  class       Class             @relation(fields: [classId], references: [id])
  status      ApplicationStatus
  startDate   DateTime
  endDate     DateTime
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  deletedAt   DateTime?

  createdById String
  createdBy   User                       @relation("ClassApplicationCreatedBy", fields: [createdById], references: [id])
  updatedById String
  updatedBy   User                       @relation("ClassApplicationUpdatedBy", fields: [updatedById], references: [id])
  answers     ClassApplicationAnswer[]
  questions   ClassApplicationQuestion[]
  comments    Comment[]
  Profile     Profile?                   @relation(fields: [profileId], references: [id])
  profileId   String?
}

enum ApplicationStatus {
  ACTIVE
  DRAFT
  ARCHIVED
}

model ClassApplicationAnswer {
  id                 String           @id @default(uuid())
  questionId         String
  question           Question         @relation(fields: [questionId], references: [id])
  classApplicationId String
  classApplication   ClassApplication @relation(fields: [classApplicationId], references: [id])
  answer             Answer           @relation(fields: [answerId], references: [id])
  answerId           String
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  deletedAt          DateTime?

  createdById String
  createdBy   User   @relation("ClassApplicationAnswerCreatedBy", fields: [createdById], references: [id])

  updatedById String
  updatedBy   User   @relation("ClassApplicationAnswerUpdatedBy", fields: [updatedById], references: [id])
}

model ClassApplicationQuestion {
  id                 String           @id @default(uuid())
  classApplication   ClassApplication @relation(fields: [classApplicationId], references: [id])
  classApplicationId String
  question           Question         @relation(fields: [questionId], references: [id])
  questionId         String
  order              Int
  required           Boolean
  points             Float
  section            String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  createdById String
  updatedById String

  createdBy User @relation("ClassApplicationQuestionCreatedBy", fields: [createdById], references: [id])
  updatedBy User @relation("ClassApplicationQuestionUpdatedBy", fields: [updatedById], references: [id])
}

model Comment {
  id            String            @id @default(uuid())
  text          String
  userId        String
  // add different possible entities here
  assignment    Assignment?       @relation(fields: [assignmentId], references: [id])
  assignmnetId  String?
  application   ClassApplication? @relation(fields: [classApplicationId], references: [id])
  applicationId String?
  status        CommentStatus
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  deletedAt     DateTime?

  createdById        String
  createdBy          User           @relation("CommentCreatedBy", fields: [createdById], references: [id])
  updatedById        String
  updatedBy          User           @relation("CommentUpdatedBy", fields: [updatedById], references: [id])
  AdminComment       AdminComment[]
  assignmentId       String?
  classApplicationId String?
  commentId          String?
}

enum CommentStatus {
  ACTIVE
  EDITED
  DELETED
}

enum CompanySize {
  STARTUP
  SMALL
  MEDIUM
  LARGE
  ENTERPRISE
}

model Company {
  id               String       @id @default(uuid())
  name             String
  description      String?
  logoId           String?
  website          String?
  size             CompanySize?
  foundedYear      Int?
  headquarters     String?
  locations        String[]
  missionStatement String?
  benefits         String?
  culture          String?
  active           Boolean      @default(true)
  notes            String?

  // Relations
  industries Tag[]
  contacts   CompanyContact[]

  // Tracking fields
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  deletedAt   DateTime?
  createdById String
  createdBy   User           @relation("CompanyCreatedBy", fields: [createdById], references: [id])
  updatedById String
  updatedBy   User           @relation("CompanyUpdatedBy", fields: [updatedById], references: [id])
  jobPostings JobPosting[]
  media       Media[]
  profiles    Profile[]
  workHistory WorkHistory[]
  placements  Placement[]
  events      EventCompany[]
  projects    Project[]
  roles       Role[]
  // userSkills UserSkill[] @relation("UserSkillCompanies")
}

enum EngagementLevel {
  ACTIVE
  RESPONSIVE
  PASSIVE
  INACTIVE
}

model CompanyContact {
  id              String          @id @default(uuid())
  companyId       String
  company         Company         @relation(fields: [companyId], references: [id])
  title           String
  department      String?
  isPrimary       Boolean         @default(false)
  engagementLevel EngagementLevel @default(PASSIVE)
  lastContactDate DateTime?
  notes           String?

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  userId String
  user   User   @relation("CompanyContactUser", fields: [userId], references: [id])

  createdById String
  createdBy   User   @relation("CompanyContactCreatedBy", fields: [createdById], references: [id])
  updatedById String
  updatedBy   User   @relation("CompanyContactUpdatedBy", fields: [updatedById], references: [id])

  roles      Role[]
  interviews Interview[]
  profileId  String?
  profile    Profile?    @relation("CompanyContactProfile", fields: [profileId], references: [id])
}

model Enrollment {
  id             String           @id @default(uuid())
  status         EnrollmentStatus
  enrollmentDate DateTime         @default(now())
  completionDate DateTime?
  finalGrade     Float?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt

  // class will be optional since if they are on the waitlist or dropped, they may not have a class
  classId String?
  class   Class?  @relation(fields: [classId], references: [id])

  userId String
  user   User   @relation("EnrollmentUser", fields: [userId], references: [id])

  createdById String
  updatedById String

  createdBy User @relation("EnrollmentCreatedBy", fields: [createdById], references: [id])
  updatedBy User @relation("EnrollmentUpdatedBy", fields: [updatedById], references: [id])
}

enum EnrollmentStatus {
  ENROLLED
  WAITLISTED
  DROPPED
  COMPLETED
}

enum EventType {
  CONFERENCE
  WORKSHOP
  NETWORKING
  HACKATHON
  CAREER_FAIR
  INFO_SESSION
}

enum EventStatus {
  DRAFT
  PUBLISHED
  CANCELLED
  COMPLETED
}

model Event {
  id                   String          @id @default(uuid())
  title                String
  description          String
  shortDescription     String
  type                 EventType
  isVirtual            Boolean
  virtualMeetingUrl    String?
  startDatetime        DateTime
  endDatetime          DateTime
  timezone             String
  registrationRequired Boolean
  registrationUrl      String?
  registrationDeadline DateTime?
  capacity             Int?
  cost                 Float?
  status               EventStatus
  featured             Boolean
  attendees            EventAttendee[]
  companies            EventCompany[]

  parentEventId String?
  parentEvent   Event?  @relation("ParentEvent", fields: [parentEventId], references: [id])
  childEvents   Event[] @relation("ParentEvent")

  locationId String
  location   Location @relation(fields: [locationId], references: [id])

  tags Tag[] @relation("EventTags")

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  createdById String
  createdBy   User   @relation("EventCreatedBy", fields: [createdById], references: [id])

  updatedById String
  updatedBy   User   @relation("EventUpdatedBy", fields: [updatedById], references: [id])
}

model EventAttendee {
  id      String @id @default(uuid())
  eventId String
  event   Event  @relation(fields: [eventId], references: [id])

  userId String
  user   User   @relation("EventAttendeeUser", fields: [userId], references: [id])

  attendanceStatus EventAttendanceStatus
  attendanceType   EventAttendanceType

  notes    String? @db.Text
  feedback String? @db.Text

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?
}

model EventCompany {
  id      String @id @default(uuid())
  eventId String
  event   Event  @relation(fields: [eventId], references: [id])

  companyId String
  company   Company @relation(fields: [companyId], references: [id])

  attendanceStatus EventAttendanceStatus
  attendanceType   EventAttendanceType

  notes    String? @db.Text
  feedback String? @db.Text

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?
}

enum EventAttendanceStatus {
  ATTENDING
  MAYBE
  NOT_ATTENDING
}

enum EventAttendanceType {
  ATTENDEE
  SPEAKER
  SPONSOR
  STAFF
  OTHER
}

enum RegistrationStatus {
  REGISTERED
  WAITLISTED
  ATTENDED
  NO_SHOW
  CANCELLED
}

model Industry {
  id               String     @id @default(uuid())
  name             String
  description      String
  parentIndustry   Industry?  @relation("IndustryHierarchy", fields: [parentIndustryId], references: [id])
  parentIndustryId String?
  subIndustries    Industry[] @relation("IndustryHierarchy")

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?
  createdById String
  createdBy   User      @relation("IndustryCreatedBy", fields: [createdById], references: [id])
  updatedById String
  updatedBy   User      @relation("IndustryUpdatedBy", fields: [updatedById], references: [id])

  jobPostingIndustries JobPostingIndustry[]
}

enum InterviewType {
  PHONE_SCREEN
  TECHNICAL
  BEHAVIORAL
  ONSITE
  FINAL
}

enum InterviewStatus {
  SCHEDULED
  COMPLETED
  CANCELLED
  RESCHEDULED
}

enum InterviewLocationType {
  PHYSICAL
  VIRTUAL
}

model Interview {
  id                    String                @id @default(uuid())
  jobApplicationId      String
  jobApplication        JobApplication        @relation(fields: [jobApplicationId], references: [id])
  type                  InterviewType
  scheduledDate         DateTime
  durationMinutes       Int
  interviewLocationType InterviewLocationType
  intervieweeId         String
  interviewee           User                  @relation("InterviewInterviewee", fields: [intervieweeId], references: [id])
  interviewers          User[]                @relation("InterviewInterviewers") //  (array of User IDs of interviewers)
  companyContactId      String?
  companyContact        CompanyContact?       @relation(fields: [companyContactId], references: [id])
  preparationNotes      String?
  status                InterviewStatus
  feedback              String?
  candidateFeedback     String?
  nextSteps             String?
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  deletedAt             DateTime?

  createdById String
  createdBy   User   @relation("InterviewCreatedBy", fields: [createdById], references: [id])
  updatedById String
  updatedBy   User   @relation("InterviewUpdatedBy", fields: [updatedById], references: [id])

  @@index([jobApplicationId])
  @@index([companyContactId])
  @@index([createdById])
  @@index([updatedById])
  @@map("interviews")
}

enum JobApplicationStatus {
  DRAFT
  SUBMITTED
  UNDER_REVIEW
  INTERVIEWING
  OFFERED
  ACCEPTED
  DECLINED
  REJECTED
}

model JobApplication {
  id                     String               @id @default(uuid())
  jobPostingId           String
  jobPosting             JobPosting           @relation(fields: [jobPostingId], references: [id])
  coverLetter            String?
  resumeId               String
  resume                 Media?               @relation("Resume", fields: [resumeId], references: [id])
  additionalMaterialsIds String[] // Array of Media IDs
  status                 JobApplicationStatus @default(DRAFT)
  referralUserId         String?
  referralUser           User?                @relation("Referral", fields: [referralUserId], references: [id])
  referralSource         String?
  submissionDate         DateTime?
  withdrawnDate          DateTime?
  withdrawnReason        String?
  internalNotes          String?
  applicantId            String
  applicant              User                 @relation("JobApplicantUser", fields: [applicantId], references: [id])

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  createdById String
  createdBy   User   @relation("JobApplicationCreatedBy", fields: [createdById], references: [id])

  updatedById String
  updatedBy   User   @relation("JobApplicationUpdatedBy", fields: [updatedById], references: [id])

  interviews              Interview[]
  jobApplicationQuestions JobApplicationQuestion[]

  placements Placement[]
}

model JobApplicationQuestion {
  id               String         @id @default(uuid())
  jobApplication   JobApplication @relation(fields: [jobApplicationId], references: [id])
  jobApplicationId String
  question         Question       @relation(fields: [questionId], references: [id])
  questionId       String
  order            Int
  required         Boolean
  points           Float
  section          String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  createdById String
  updatedById String

  createdBy User @relation("JobApplicationQuestionCreatedBy", fields: [createdById], references: [id])
  updatedBy User @relation("JobApplicationQuestionUpdatedBy", fields: [updatedById], references: [id])
}

enum JobPostingRemoteOption {
  ON_SITE
  HYBRID
  REMOTE
}

enum JobPostingEmploymentType {
  FULL_TIME
  PART_TIME
  CONTRACT
  INTERNSHIP
}

enum JobPostingExperienceLevel {
  ENTRY
  MID
  SENIOR
  EXECUTIVE
}

enum JobPostingStatus {
  DRAFT
  OPEN
  FILLED
  CLOSED
}

model JobPostingIndustry {
  jobPostingId String
  industryId   String
  jobPosting   JobPosting @relation(fields: [jobPostingId], references: [id])
  industry     Industry   @relation(fields: [industryId], references: [id])

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?
  createdById String
  createdBy   User      @relation("JobPostingIndustryCreatedBy", fields: [createdById], references: [id])
  updatedById String
  updatedBy   User      @relation("JobPostingIndustryUpdatedBy", fields: [updatedById], references: [id])

  @@id([jobPostingId, industryId])
}

model JobPosting {
  id                      String                    @id @default(uuid())
  companyId               String
  company                 Company                   @relation(fields: [companyId], references: [id])
  title                   String
  description             String
  shortDescription        String
  location                String
  remoteOption            JobPostingRemoteOption
  employmentType          JobPostingEmploymentType
  experienceLevel         JobPostingExperienceLevel
  educationRequirements   String?
  salaryMin               Float?
  salaryMax               Float?
  benefits                String?
  applicationInstructions String?
  externalPostingUrl      String?
  internalNotes           String?
  status                  JobPostingStatus          @default(DRAFT)
  postedDate              DateTime?
  deadlineDate            DateTime?
  industries              JobPostingIndustry[]
  applicants              JobApplication[]

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  createdById String
  createdBy   User   @relation("JobPostingCreatedBy", fields: [createdById], references: [id])

  updatedById String
  updatedBy   User   @relation("JobPostingUpdatedBy", fields: [updatedById], references: [id])
}

model Location {
  id            String       @id @default(uuid())
  name          String
  addressLine1  String
  addressLine2  String?
  city          String
  stateProvince String
  postalCode    String
  country       String
  latitude      Float
  longitude     Float
  type          LocationType
  capacity      Int?
  notes         String?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  deletedAt     DateTime?
  events        Event[]

  createdById String
  createdBy   User      @relation("LocationCreatedBy", fields: [createdById], references: [id])
  updatedById String
  updatedBy   User      @relation("LocationUpdatedBy", fields: [updatedById], references: [id])
  profile     Profile[] @relation("LocationProfile")

  // Relation to VenueContactInfo
  contact VenueContactInfo?

  @@index([createdById])
  @@index([updatedById])
  @@map("locations")
}

enum LocationType {
  CAMPUS
  OFFICE
  VENUE
  REMOTE
}

enum MediaType {
  VIDEO
  IMAGE
  PDF
  AUDIO
  DOCUMENT
  OTHER
}

//do check the storage types here and add/remove as needed
enum StorageType {
  LOCAL
  YOUTUBE
  S3
  CLOUDINARY
  EXTERNAL
}

model Media {
  id               String      @id @default(uuid())
  title            String
  type             MediaType
  storageType      StorageType
  url              String
  originalFilename String?
  sizeInBytes      Int?
  mimeType         String?
  metadata         Json? // Type-specific attributes stored as JSON

  // Nullable foreign keys for various relations
  userId    String?
  user      User?    @relation("UserMedia", fields: [userId], references: [id])
  profileId String?
  profile   Profile? @relation("ProfileMedia", fields: [profileId], references: [id])
  companyId String?
  company   Company? @relation(fields: [companyId], references: [id])

  // Tracking fields
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  deletedAt             DateTime?
  createdById           String
  createdBy             User                   @relation("MediaCreatedBy", fields: [createdById], references: [id])
  updatedById           String
  updatedBy             User                   @relation("MediaUpdatedBy", fields: [updatedById], references: [id])
  assignmentSubmissions AssignmentSubmission[] @relation("AssignmentSubmissionFiles")
  jobApplications       JobApplication[]       @relation("Resume")
  profilePictures       Profile[]              @relation("ProfilePicture")
  projects              Project[]
}

model Placement {
  id                     String          @id @default(uuid())
  userId                 String
  user                   User            @relation("UserPlacements", fields: [userId], references: [id])
  companyId              String
  company                Company         @relation(fields: [companyId], references: [id])
  jobApplicationId       String?
  jobApplication         JobApplication? @relation(fields: [jobApplicationId], references: [id])
  jobTitle               String
  employmentType         EmploymentType
  startDate              DateTime
  endDate                DateTime?
  isCurrent              Boolean
  salary                 Float
  compensationDetails    String?
  matchQuality           MatchQuality
  placementFacilitatorId String
  placementFacilitator   User            @relation("PlacementFacilitator", fields: [placementFacilitatorId], references: [id])
  verified               Boolean         @default(false)
  verificationDate       DateTime?
  createdAt              DateTime        @default(now())
  updatedAt              DateTime        @updatedAt
  deletedAt              DateTime?

  createdById String
  createdBy   User   @relation("PlacementCreatedBy", fields: [createdById], references: [id])
  updatedById String
  updatedBy   User   @relation("PlacementUpdatedBy", fields: [updatedById], references: [id])

  placementFeedback PlacementFeedback[]

  @@index([userId])
  @@index([companyId])
  @@index([jobApplicationId])
  @@index([placementFacilitatorId])
  @@index([createdById])
  @@index([updatedById])
  @@map("placements")
}

enum MatchQuality {
  EXCELLENT
  GOOD
  FAIR
  POOR
}

model PlacementFeedback {
  id                     String            @id @default(uuid())
  placementId            String
  placement              Placement         @relation(fields: [placementId], references: [id])
  feedbackType           FeedbackType
  respondentId           String
  respondent             User              @relation("FeedbackRespondent", fields: [respondentId], references: [id])
  satisfactionLevel      SatisfactionLevel
  preparednessRating     Int // (1-5 scale)
  skillsMatchRating      Int // (1-5 scale)
  cultureFitRating       Int // (1-5 scale)
  feedbackText           String            @db.Text
  improvementSuggestions String?           @db.Text
  followUpNeeded         Boolean           @default(false)
  createdAt              DateTime          @default(now())
  updatedAt              DateTime          @updatedAt
  deletedAt              DateTime?
  createdById            String
  createdBy              User              @relation("FeedbackCreatedBy", fields: [createdById], references: [id])
  updatedById            String
  updatedBy              User              @relation("FeedbackUpdatedBy", fields: [updatedById], references: [id])

  @@index([placementId])
  @@index([respondentId])
  @@index([createdById])
  @@index([updatedById])
  @@map("placement_feedback")
}

enum FeedbackType {
  STUDENT
  EMPLOYER
  ADMIN
}

enum SatisfactionLevel {
  VERY_SATISFIED
  SATISFIED
  NEUTRAL
  DISSATISFIED
  VERY_DISSATISFIED
}

model Profile {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation("ProfileUser", fields: [userId], references: [id])

  // Core Identity
  firstName        String
  lastName         String
  username         String?
  jobTitle         String?
  department       String?
  bio              String?
  profilePictureId String? @unique
  profilePicture   Media?  @relation("ProfilePicture", fields: [profilePictureId], references: [id])

  // Communication & Preferences
  email                   String
  phoneNumber             String
  timezone                String?
  languagePreference      String?
  notificationPreferences Json?

  // Location & Addressing
  locationId String?
  location   Location? @relation("LocationProfile", fields: [locationId], references: [id])

  // Employment / Affiliation
  companyId String? //if user works in a company
  company   Company? @relation(fields: [companyId], references: [id])

  // Web3 Wallet
  walletAddress String? @unique

  // Socials & Metadata
  socialMediaLinks Json? // { "linkedin": "...", "twitter": "...", etc. }
  customFields     Json? // Extensible field for anything else (certs, licenses, etc.)

  // Form & Onboarding Meta
  onboardingCompleted Boolean @default(false)

  // Applications
  applicationResponses ClassApplication[]

  // Assignments & Projects
  assignmentSubmissions AssignmentSubmission[]
  projectCollaborations ProjectCollaborator[]  @relation("ProjectCollaboratorProfile")

  // Skills & Tags
  skills         UserSkill[] //user's skills
  endorsedSkills UserSkill[] @relation("SkillEndorsements") // skills this profile endorsed
  tags           Tag[]       @relation("ProfileTags") //reference to tag model

  // Work Experience
  workHistory WorkHistory[] @relation("WorkHistoryProfile")

  // If user is a contact point for a company
  companyContacts CompanyContact[] @relation("CompanyContactProfile")

  media Media[] @relation("ProfileMedia")

  //metadata tracking
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  createdById String
  createdBy   User   @relation("ProfileCreatedBy", fields: [createdById], references: [id])

  updatedById String
  updatedBy   User   @relation("ProfileUpdatedBy", fields: [updatedById], references: [id])
}

model Project {
  id               String           @id @default(uuid())
  title            String
  description      String
  shortDescription String
  status           ProjectStatus
  visibility       VisibilityStatus
  githubUrl        String?          @db.VarChar(2048)
  demoUrl          String?          @db.VarChar(2048)
  outcome          String?
  challenges       String?
  isFeatured       Boolean          @default(false)

  startDate DateTime
  endDate   DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  createdById String
  createdBy   User   @relation("CreatedProjects", fields: [createdById], references: [id])

  updatedById String
  updatedBy   User   @relation("UpdatedProjects", fields: [updatedById], references: [id])

  classId String?
  class   Class?  @relation("ClassProjects", fields: [classId], references: [id])

  userId String?
  owner  User?   @relation("ProjectOwner", fields: [userId], references: [id])

  media                Media[]
  projectCollaborators ProjectCollaborator[]
  company              Company[]
  tags                 Tag[]                 @relation("ProjectTags")
  userSkills           UserSkill[]           @relation("UserSkillProjects")
}

enum ProjectStatus {
  IN_PROGRESS
  COMPLETED
  ARCHIVED
}

enum VisibilityStatus {
  PRIVATE
  PUBLIC
  INTERNAL
}

model ProjectCollaborator {
  id            String    @id @default(uuid())
  role          String
  contributions String
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  deletedAt     DateTime?
  profileId     String?
  profile       Profile?  @relation("ProjectCollaboratorProfile", fields: [profileId], references: [id])

  createdById String
  createdBy   User   @relation("ProjectCollaboratorCreatedBy", fields: [createdById], references: [id])

  updatedById String
  updatedBy   User   @relation("ProjectCollaboratorUpdatedBy", fields: [updatedById], references: [id])

  projectId String
  project   Project @relation(fields: [projectId], references: [id])

  userId String
  user   User   @relation("ProjectCollaboratorUser", fields: [userId], references: [id])

  tags Tag[] @relation("ProjectCollaboratorTags")
}

enum QuestionType {
  NUMBER
  TEXT
  SELECT
  MULTISELECT
  SCALE
  DATE
}

model Question {
  id          String       @id @default(uuid())
  text        String
  description String?
  type        QuestionType
  required    Boolean
  order       Int
  metadata    Json?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  deletedAt   DateTime?

  createdById String
  createdBy   User   @relation("QuestionCreatedBy", fields: [createdById], references: [id])

  updatedById String
  updatedBy   User   @relation("QuestionUpdatedBy", fields: [updatedById], references: [id])

  assignmentQuestions       AssignmentQuestion[]
  classApplicationQuestions ClassApplicationQuestion[]
  jobApplicationQuestions   JobApplicationQuestion[]
  tags                      Tag[]                      @relation("QuestionTags")

  answers                     Answer[]
  assignmentSubmissionAnswers AssignmentSubmissionAnswer[]
  classApplicationAnswers     ClassApplicationAnswer[]
}

model Role {
  id          String       @id @default(uuid())
  name        String // e.g., "CTO", "Head of BD", "Engineering Manager"
  description String // brief explanation of the role
  category    RoleCategory // e.g., "executive", "management", etc.
  department  String? // department this role typically belongs to
  level       RoleLevel // e.g., "entry", "mid", "senior", etc.
  isInternal  Boolean // whether used for internal roles vs external company contacts

  userId String
  user   User   @relation("RoleUser", fields: [userId], references: [id])

  companyId String
  company   Company @relation(fields: [companyId], references: [id])

  // Metadata
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  createdById String
  createdBy   User   @relation("RoleCreatedBy", fields: [createdById], references: [id])

  updatedById String
  updatedBy   User   @relation("RoleUpdatedBy", fields: [updatedById], references: [id])

  companyContacts CompanyContact[]
}

enum RoleCategory {
  EXECUTIVE
  MANAGEMENT
  TECHNICAL
  BUSINESS
  OPERATIONS
  OTHER
}

enum RoleLevel {
  ENTRY
  MID
  SENIOR
  DIRECTOR
  EXECUTIVE
  C_SUITE
}

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider        = "prisma-client-js"
  output          = "../src/generated/prisma"
  previewFeatures = ["prismaSchemaFolder"]
}

datasource db {
  provider  = "postgresql"
  // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
  // Further reading:
  // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
  // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// nextauth required schemas execpt user

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refreshToken      String?
  accessToken       String?
  expiresAt         Int?
  tokenType         String?
  scope             String?
  idToken           String?
  sessionState      String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
}

// Optional for WebAuthn support
model Authenticator {
  credentialID         String  @unique
  userId               String
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, credentialID])
}

model Section {
  id        String    @id @default(uuid())
  header    String
  metadata  Json
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  createdById String
  createdBy   User   @relation("SectionCreatedBy", fields: [createdById], references: [id])

  updatedById String
  updatedBy   User   @relation("SectionUpdatedBy", fields: [updatedById], references: [id])
}

model Tag {
  tagname String @id
  color   String

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  createdById String
  createdBy   User   @relation("TagCreatedBy", fields: [createdById], references: [id])

  updatedById String
  updatedBy   User   @relation("TagUpdatedBy", fields: [updatedById], references: [id])

  projects                Project[]             @relation("ProjectTags")
  profiles                Profile[]             @relation("ProfileTags")
  answers                 Answer[]              @relation("AnswerTags")
  assignments             Assignment[]          @relation("AssignmentTags")
  events                  Event[]               @relation("EventTags")
  companies               Company[]
  projectCollaboratorTags ProjectCollaborator[] @relation("ProjectCollaboratorTags")
  question                Question[]            @relation("QuestionTags")
  userSkills              UserSkill[]           @relation("UserSkillTags")
}

model User {
  id       String  @id @default(uuid())
  username String? @unique

  // legal name
  name String?

  // Added for authentication with nextauth/authjs
  email          String          @unique
  hashedPassword String
  emailVerified  DateTime?
  image          String?
  accounts       Account[]
  sessions       Session[]
  // Optional for WebAuthn support
  Authenticator  Authenticator[]

  role      UserRole
  status    UserStatus
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  deletedAt DateTime?
  lastLogin DateTime?

  adminCommentsCreated AdminComment[] @relation("AdminCommentCreatedBy")
  adminCommentsUpdated AdminComment[] @relation("AdminCommentUpdatedBy")

  answersCreated Answer[] @relation("AnswerCreatedBy")
  answersUpdated Answer[] @relation("AnswerUpdatedBy")

  assignmentsCreated Assignment[] @relation("AssignmentCreatedBy")
  assignmentsUpdated Assignment[] @relation("AssignmentUpdatedBy")

  classesCreated Class[] @relation("ClassCreatedBy")
  classesUpdated Class[] @relation("ClassUpdatedBy")

  assignmentQuestionsCreated AssignmentQuestion[] @relation("AssignmentQuestionCreatedBy")
  assignmentQuestionsUpdated AssignmentQuestion[] @relation("AssignmentQuestionUpdatedBy")

  assignmentSubmissionsCreated AssignmentSubmission[] @relation("AssignmentSubmissionCreatedBy")
  assignmentSubmissionsUpdated AssignmentSubmission[] @relation("AssignmentSubmissionUpdatedBy")
  assignmentSubmissionsGraded  AssignmentSubmission[] @relation("GradedBy")

  assignmentSubmissionAnswersCreated AssignmentSubmissionAnswer[] @relation("AssignmentSubmissionAnswerCreatedBy")
  assignmentSubmissionAnswersUpdated AssignmentSubmissionAnswer[] @relation("AssignmentSubmissionAnswerUpdatedBy")

  classesTeaching           Class[] @relation("ClassTeachers")
  classesTeachingAssistants Class[] @relation("ClassTeachingAssistants")

  classApplicationsCreated ClassApplication[] @relation("ClassApplicationCreatedBy")
  classApplicationsUpdated ClassApplication[] @relation("ClassApplicationUpdatedBy")

  classApplicationAnswersCreated ClassApplicationAnswer[] @relation("ClassApplicationAnswerCreatedBy")
  classApplicationAnswersUpdated ClassApplicationAnswer[] @relation("ClassApplicationAnswerUpdatedBy")

  classApplicationQuestionsCreated ClassApplicationQuestion[] @relation("ClassApplicationQuestionCreatedBy")
  classApplicationQuestionsUpdated ClassApplicationQuestion[] @relation("ClassApplicationQuestionUpdatedBy")

  commentsCreated Comment[] @relation("CommentCreatedBy")
  commentsUpdated Comment[] @relation("CommentUpdatedBy")

  companyCreated Company[] @relation("CompanyCreatedBy")
  companyUpdated Company[] @relation("CompanyUpdatedBy")

  companyContactsCreated CompanyContact[] @relation("CompanyContactCreatedBy")
  companyContactsUpdated CompanyContact[] @relation("CompanyContactUpdatedBy")
  companyContactUser     CompanyContact[] @relation("CompanyContactUser")

  enrollmentCreated Enrollment[] @relation("EnrollmentCreatedBy")
  enrollmentUpdated Enrollment[] @relation("EnrollmentUpdatedBy")
  enrollments       Enrollment[] @relation("EnrollmentUser")

  eventCreated   Event[]         @relation("EventCreatedBy")
  eventUpdated   Event[]         @relation("EventUpdatedBy")
  eventAttendees EventAttendee[] @relation("EventAttendeeUser")

  industryCreated Industry[] @relation("IndustryCreatedBy")
  industryUpdated Industry[] @relation("IndustryUpdatedBy")

  interviewCreated      Interview[] @relation("InterviewCreatedBy")
  interviewUpdated      Interview[] @relation("InterviewUpdatedBy")
  interviewInterviewee  Interview[] @relation("InterviewInterviewee")
  interviewInterviewers Interview[] @relation("InterviewInterviewers")

  jobApplicationsCreated JobApplication[] @relation("JobApplicationCreatedBy")
  jobApplicationsUpdated JobApplication[] @relation("JobApplicationUpdatedBy")
  jobReferrals           JobApplication[] @relation("Referral")
  jobApplications        JobApplication[] @relation("JobApplicantUser")

  jobApplicationQuestionsCreated JobApplicationQuestion[] @relation("JobApplicationQuestionCreatedBy")
  jobApplicationQuestionsUpdated JobApplicationQuestion[] @relation("JobApplicationQuestionUpdatedBy")

  jobPostingIndustriesCreated JobPostingIndustry[] @relation("JobPostingIndustryCreatedBy")
  jobPostingIndustriesUpdated JobPostingIndustry[] @relation("JobPostingIndustryUpdatedBy")

  jobPostingsCreated JobPosting[] @relation("JobPostingCreatedBy")
  jobPostingsUpdated JobPosting[] @relation("JobPostingUpdatedBy")

  locationCreated Location[] @relation("LocationCreatedBy")
  locationUpdated Location[] @relation("LocationUpdatedBy")

  mediaCreated Media[] @relation("MediaCreatedBy")
  mediaUpdated Media[] @relation("MediaUpdatedBy")
  media        Media[] @relation("UserMedia")

  placementCreated     Placement[] @relation("PlacementCreatedBy")
  placementUpdated     Placement[] @relation("PlacementUpdatedBy")
  placementFacilitator Placement[] @relation("PlacementFacilitator")
  placements           Placement[] @relation("UserPlacements")

  placementFeedbackCreated    PlacementFeedback[] @relation("FeedbackCreatedBy")
  placementFeedbackUpdated    PlacementFeedback[] @relation("FeedbackUpdatedBy")
  placementFeedbackRespondent PlacementFeedback[] @relation("FeedbackRespondent")

  profileCreated Profile[] @relation("ProfileCreatedBy")
  profileUpdated Profile[] @relation("ProfileUpdatedBy")
  profile        Profile[] @relation("ProfileUser")

  projectCreated Project[] @relation("CreatedProjects")
  projectUpdated Project[] @relation("UpdatedProjects")
  projectOwner   Project[] @relation("ProjectOwner")

  projectCollaboratorCreated ProjectCollaborator[] @relation("ProjectCollaboratorCreatedBy")
  projectCollaboratorUpdated ProjectCollaborator[] @relation("ProjectCollaboratorUpdatedBy")
  projectCollaborator        ProjectCollaborator[] @relation("ProjectCollaboratorUser")

  questionCreated Question[] @relation("QuestionCreatedBy")
  questionUpdated Question[] @relation("QuestionUpdatedBy")

  roleCreated Role[] @relation("RoleCreatedBy")
  roleUpdated Role[] @relation("RoleUpdatedBy")
  roles       Role[] @relation("RoleUser")

  sectionCreated Section[] @relation("SectionCreatedBy")
  sectionUpdated Section[] @relation("SectionUpdatedBy")

  tagCreated Tag[] @relation("TagCreatedBy")
  tagUpdated Tag[] @relation("TagUpdatedBy")

  userSkillCreated UserSkill[] @relation("UserSkillCreatedBy")
  userSkillUpdated UserSkill[] @relation("UserSkillUpdatedBy")

  venueContactInfoCreated VenueContactInfo[] @relation("ContactInfoCreatedBy")
  venueContactInfoUpdated VenueContactInfo[] @relation("ContactInfoUpdatedBy")

  walletCreated Wallet[] @relation("WalletCreatedBy")
  walletUpdated Wallet[] @relation("WalletUpdatedBy")
  wallets       Wallet[] @relation("WalletUser")

  workHistoryCreated WorkHistory[] @relation("WorkHistoryCreatedBy")
  workHistoryUpdated WorkHistory[] @relation("WorkHistoryUpdatedBy")
  workHistoryUser    WorkHistory[] @relation("WorkHistoryUser")
}

enum UserRole {
  ADMIN
  STANDARD
  INSTRUCTOR
  MODERATOR
}

enum UserStatus {
  ACTIVE
  INACTIVE
  PENDING
  DELETED
}

model UserSkill {
  id        String @id @default(uuid())
  profileId String
  tagname   String //skill name pointing to tags

  profile Profile @relation(fields: [profileId], references: [id])
  tag     Tag     @relation("UserSkillTags", fields: [tagname], references: [tagname])

  selfRating Float? // optional self-assessment (0.0 - 5.0)
  notes      String? // optional custom annotation

  // learnedAt
  // learnedAtCompanies Company[] @relation("UserSkillCompanies")
  learnedAtProjects Project[] @relation("UserSkillProjects")

  // endorsements
  endorsedBy Profile[] @relation("SkillEndorsements")

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  createdById String
  createdBy   User   @relation("UserSkillCreatedBy", fields: [createdById], references: [id])

  updatedById     String
  updatedBy       User          @relation("UserSkillUpdatedBy", fields: [updatedById], references: [id])
  workHistoryUser WorkHistory[]
}

model VenueContactInfo {
  id          String    @id @default(uuid())
  locationId  String    @unique
  location    Location  @relation(fields: [locationId], references: [id])
  email       String?
  phone       String?
  website     String?
  contactName String?
  department  String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?

  createdById String
  createdBy   User   @relation("ContactInfoCreatedBy", fields: [createdById], references: [id])
  updatedById String
  updatedBy   User   @relation("ContactInfoUpdatedBy", fields: [updatedById], references: [id])

  @@index([locationId])
  @@index([createdById])
  @@index([updatedById])
  @@map("contact_info")
}

model Wallet {
  publicKey String    @id
  userId    String
  user      User      @relation("WalletUser", fields: [userId], references: [id])
  active    Boolean
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  createdById String
  createdBy   User   @relation("WalletCreatedBy", fields: [createdById], references: [id])

  updatedById String
  updatedBy   User   @relation("WalletUpdatedBy", fields: [updatedById], references: [id])
}

model WorkHistory {
  id             String         @id @default(uuid()) // Primary Key
  userId         String // Foreign Key to User
  companyName    String // Company name
  companyId      String? // Nullable Foreign Key to Company
  title          String // Job title
  description    String // Job description
  startDate      DateTime // Start date of employment
  endDate        DateTime? // Nullable End date (for current positions)
  isCurrent      Boolean // Whether this is the current job
  location       String // Location where work was performed
  employmentType EmploymentType // Enum for employment type
  skillsUsed     UserSkill[] // Many-to-many relation to Skill
  achievements   String? // Notable accomplishments
  references     String? // Contact info for references
  verified       Boolean // If verified by admin
  profileId      String?
  profile        Profile?       @relation("WorkHistoryProfile", fields: [profileId], references: [id])

  // Foreign Key Relations
  user    User     @relation("WorkHistoryUser", fields: [userId], references: [id]) // Link to User
  company Company? @relation(fields: [companyId], references: [id]) // Link to Company (nullable)

  // Timestamps
  createdById String
  createdBy   User   @relation("WorkHistoryCreatedBy", fields: [createdById], references: [id])
  updatedById String
  updatedBy   User   @relation("WorkHistoryUpdatedBy", fields: [updatedById], references: [id])
}

enum EmploymentType {
  FULL_TIME
  PART_TIME
  CONTRACT
  INTERNSHIP
}
